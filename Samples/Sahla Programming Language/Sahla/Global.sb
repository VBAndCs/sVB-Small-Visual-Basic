ProEndMsg = "انتهى البرنامج.. اضغط أي زر لإغلاقه..."
UnknownCommandMsg = "أمر غير معروف: "

_True = "نعم"
_False = "لا"
_If = "لو"
_ElseIf = "أو لو"
_Else = "وإلا"
_EndIf = "فقط"
_And = "و"
_Or = "أو"
_While = "بينما"
_Wend = "كرر"
_For = "من"
_To1 = "إلى"
_To2 = "حتى"
_Step = "بزيادة"
_Next = "زد"
_ExitLoop = "اخرج"
_Write = "اكتب"
_Line1 = "سطرا"
_Line2 = "السطر"
_Read = "اقرأ"
_Text1 = "نصا"
_Text2 = "النص"
_Number1 = "عددا"
_Number2 = "العدد"
_Random = "عشوائي"
_Wait = "انتظر"
_Sound = "صوت"
_Beep = "بيب"
_Bell = "جرس"
_Ding = "رنة"
_Click = "ضغطة"
_Chime = "نغمة"
_IntegralDivision = "÷"
_CommentSymbol = "#"

BasicWords = {
   _True, _False, _If, _Else, _ElseIf, _EndIf, _And, _Or,
   _While, _Wend, _For, _To1, _To2, _Step, _Next, _ExitLoop,
   _Write, _Line1, _Line2, _Read, _Text1, _Text2, _Number1, _Number2,
   _Wait, _Random, _Sound, _Beep, _Bell, _Ding, _Click, _Chime
}

CommandsCompletionList = {
   _Write,
   _Write & " " & _Line2,
   _If, _Else, _ElseIf, _EndIf,
   _While, _Wend, _For, _Next, _ExitLoop,
   _Wait,
   _Sound,
   _Sound & " " & _Beep,
   _Sound & " " & _Bell,
   _Sound & " " & _Ding,
   _Sound & " " & _Click,
   _Sound & " " & _Chime
}

OperatorsCompletionList = {
   _Read & " " & _Text1,
   _Read & " " & _Number1,
   _Or, _True, _False,
   _To1, _To2, _Step, _Random
}

Opertors = {
   "=", "<", ">", "(", ")",
   "+", "-", "*", "×", "/", _IntegralDivision, "%", "^"
}

FontNames = Desktop.FontNames

_SettingsFile = "%LOCALAPPDATA%/Sahla.settings"
_Settings = File.ReadLines(_SettingsFile)
If _Settings = "" Then
   Ops!FontName = "Segoe UI"
   Ops!FontSize = 20
   Ops!Bold = False
   Ops!Italic = False
   Ops!Underlined = False
   Ops!ForeColor = Colors.Black
   Ops!BackColor = Colors.White
   Ops!FirstTime = True
Else
   Ops!FontName = _Settings[1]
   Ops!FontSize = _Settings[2]
   Ops!Bold = _Settings[3]
   Ops!Italic = _Settings[4]
   Ops!Underlined = _Settings[5]
   Ops!ForeColor = _Settings[6]
   Ops!BackColor = _Settings[7]
   Ops!FirstTime = _Settings[8]
EndIf

Statements = {}				' Array of code lines (strings)
LineIndex = 1 	    			' Our program counter
Tokens = {}					' Tokens array for the current line
Vars = {}						' Array containing variables of current proogram
WhileStack = "WhileStack"		' Stack name for WHILE loops
ForStack = "ForStack"			' Stack name for FOR loops
_KeywordsColor = "#7777ff"
EditorTextBox = ""
LblFormat = ""
LblLine = ""
Terminated = False

Timer.Interval = 20
Timer.Tick = ManageCodeColoring
_ColoringRequested = False
_StillColoring = False

Sub Tokenize(line, lineNum, commentSymbol)
   Tokens = {}
   tokenIndex = 1
   currentToken = ""
   tokenStartCol = 0
   inString = False
   len = Text.GetLength(line)
   
   For col = 1 To len
      ch = line[col]
      
      If ch = Chars.Cr Or ch = Chars.Lf Then
         ContinueLoop
      ElseIf ch = """" Then
         If inString = False Then
            If currentToken <> "" Then
               Tokens[tokenIndex] = {lineNum, tokenStartCol, currentToken}
               tokenIndex = tokenIndex + 1
            EndIf
            inString = True
            tokenStartCol = col
            currentToken = ch
         Else
            currentToken = currentToken & ch
            Tokens[tokenIndex] = {lineNum, tokenStartCol, currentToken}
            tokenIndex = tokenIndex + 1
            currentToken = ""
            inString = False
         EndIf
         
      ElseIf inString Then
         currentToken = currentToken & ch
         
      ElseIf ch = commentSymbol Then
         If currentToken <> "" Then
            Tokens[tokenIndex] = {lineNum, tokenStartCol, currentToken}
            tokenIndex = tokenIndex + 1
         EndIf
         
         For i = col - 1 To 1 Step -1
            If line[i] <> " " Then
               col = i + 1
               ExitLoop
            EndIf
         Next
         
         Tokens[tokenIndex] = {lineNum, col, Text.GetSubTextToEnd(line, col)}
         Return
         
      ElseIf ch = " " Then
         If currentToken <> "" Then
            If tokenIndex = 2 And Tokens[1][3] = _Or And currentToken = _If Then
               Tokens[1] = {lineNum, Tokens[1][2], _ElseIf}
            Else
               Tokens[tokenIndex] = {lineNum, tokenStartCol, currentToken}
               tokenIndex = tokenIndex + 1
            EndIf
            currentToken = ""
         EndIf
         
      ElseIf Opertors.ContainsValue(ch) Then
         If currentToken <> "" Then
            Tokens[tokenIndex] = {lineNum, tokenStartCol, currentToken}
            tokenIndex = tokenIndex + 1
            currentToken = ""
         EndIf
         Tokens[tokenIndex] = {lineNum, col, ch}
         tokenIndex = tokenIndex + 1
         
      ElseIf currentToken = "" Then
         tokenStartCol = col
         currentToken = ch
         
      ElseIf (ch = "." Or Chars.IsDigit(ch)) = False And currentToken.IsNumeric Then
         Tokens[tokenIndex] = {lineNum, tokenStartCol, currentToken}
         tokenIndex = tokenIndex + 1
         tokenStartCol = col
         currentToken = ch
         
      Else
         currentToken = currentToken & ch
      EndIf
   Next
   
   If inString Then
      Tokens[tokenIndex] = {lineNum, tokenStartCol, currentToken & """"}
   ElseIf currentToken <> "" Then
      Tokens[tokenIndex] = {lineNum, tokenStartCol, currentToken}
   EndIf
EndSub

Sub Run()
   Terminated = False
   TW.Clear()
   Vars = {}
   Stack.Clear(WhileStack)
   Stack.Clear(ForStack)
   
   code = Text.Replace(EditorTextBox.Text, Chars.CrLf, Chars.Lf)
   Statements = Text.Split(code, Chars.Lf, False, False)
   LineIndex = 1
   statementsCount = Statements.Count
   
   While LineIndex <= statementsCount
      Tokenize(Statements[LineIndex], LineIndex, _CommentSymbol)
      ExecuteLine()
      If LineIndex <= Statements.Count Then
         LineIndex = LineIndex + 1
      EndIf
      
      If TW.IsClosed Then
         EditorTextBox.Focus()
         Return
      EndIf
   Wend
   
   Terminate(ProEndMsg, False)
   EditorTextBox.Focus()
EndSub

Sub EndProgram()
   Terminate(ProEndMsg, False)
EndSub

Sub Terminate(msg, isError)
   If isError Then
      TW.AppendFormatted(
         Chars.Lf & msg,
         "", 20,
         True, False, False,
         Colors.Red, Colors.Yellow
      )
   Else
      TW.Write(Chars.Lf & msg)
   EndIf
   
   TW.PauseWithoutMessage()
   TW.Close()
EndSub

Sub ExecuteLine()
   tokensCount = Tokens.Count
   
   If tokensCount = 0 Or TW.IsClosed Then
      Return
   EndIf
   
   command = Text.Trim(Tokens[1][3])
   If command[1] = _CommentSymbol Then ' Ignore the comment
      Return
   ElseIf command = _Wait Then
      If tokensCount = 1 Then
         Program.Delay(1000)
      Else
         result = EvaluateExpression(2)
         nextPos = result[2]
         If nextPos < tokensCount Then
            ReportError("'" & Tokens[nextPos][3] & "' غير متوقعة هنا", LineIndex, nextPos)
            Return
         EndIf
         t = result[1]
         If Text.IsNumeric(t) Then
            Program.Delay(t)
         Else
            ReportError("'" & t & "' لا تصلح كمدة زمنية", LineIndex, 2)
         EndIf
      EndIf
   ElseIf command = _Write Then
      nextCommand = Tokens[2][3]
      If tokensCount = 1 Then
         ReportError("يجب أن تكتب الرسالة بعد الأمر '" & _Write & "'", LineIndex, 1)
      ElseIf nextCommand = _Line1 Or nextCommand = _Line2 Then
         If tokensCount = 2 Then
            msg = ""
         Else
            result = EvaluateExpression(3)
            msg = result[1]
            nextPos = result[2]
            If nextPos < tokensCount Then
               ReportError("'" & Tokens[nextPos][3] & "' غير متوقعة هنا", LineIndex, nextPos)
               Return
            EndIf
         EndIf
         
         If TW.IsClosed Then
            Return
         EndIf
         TW.WriteLine(FixBool(msg))
         
      Else
         result = EvaluateExpression(2)
         nextPos = result[2]
         If nextPos < tokensCount Then
            ReportError("'" & Tokens[nextPos][3] & "' غير متوقعة هنا", LineIndex, nextPos)
            Return
         EndIf
         
         If TW.IsClosed Then
            Return
         EndIf
         TW.Write(FixBool(result[1]))
      EndIf
      
   ElseIf command = _For Then
      ProcessForLoopHeader()
      
   ElseIf command = _Next Then
      ProcessForLoopNext()
      
   ElseIf command = _While Then
      ProcessWhileLoopHeader()
      
   ElseIf command = _Wend Then
      ProcessWhileLoopEnd()
      
   ElseIf command = _If Then
      ProcessIfBlock()
      
   ElseIf command = _ExitLoop Then
      ProcessExitLoop(LineIndex)
      
   ElseIf command = _ElseIf Or command = _Else Or command = _EndIf Then
      Return
      
   ElseIf command = _Sound Then
      nextCommand = Tokens[2][3]
      If tokensCount = 1 Then
         ReportError("يجب أن تكتب اسم الصوت أو مسار ملف صوت", LineIndex, 1)
      ElseIf nextCommand = _Beep Then
         If tokensCount > 2 Then
            ReportError("'" & Tokens[3][3] & "' غير متوقعة هنا", LineIndex, 3)
            Return
         EndIf
         Sound.PlayBeep()
      ElseIf nextCommand = _Bell Then
         If tokensCount > 2 Then
            ReportError("'" & Tokens[3][3] & "' غير متوقعة هنا", LineIndex, 3)
            Return
         EndIf
         Sound.PlayBellRing()
      ElseIf nextCommand = _Ding Then
         If tokensCount > 2 Then
            ReportError("'" & Tokens[3][3] & "' غير متوقعة هنا", LineIndex, 3)
            Return
         EndIf
         Sound.PlayDing()
      ElseIf nextCommand = _Click Then
         If tokensCount > 2 Then
            ReportError("'" & Tokens[3][3] & "' غير متوقعة هنا", LineIndex, 3)
            Return
         EndIf
         Sound.PlayClick()
      ElseIf nextCommand = _Chime Then
         If tokensCount > 2 Then
            ReportError("'" & Tokens[3][3] & "' غير متوقعة هنا", LineIndex, 3)
            Return
         EndIf
         Sound.PlayChime()
      Else
         result = EvaluateExpression(2)
         nextPos = result[2]
         If nextPos < tokensCount Then
            ReportError("'" & Tokens[nextPos][3] & "' غير متوقعة هنا", LineIndex, nextPos)
            Return
         EndIf
         
         Sound.Play(result[1])
      EndIf
      
   ElseIf tokensCount >= 3 And Tokens[2][3] = "=" Then ' varName
      If IsValidVarName(command, LineIndex, 1) = False Then
         Return
      EndIf
      
      result = EvaluateExpression(3)
      nextPos = result[2]
      If nextPos < tokensCount Then
         ReportError("'" & Tokens[nextPos][3] & "' غير متوقعة هنا", LineIndex, nextPos)
         Return
      EndIf
      Vars[command] = result[1]
      
   Else
      ReportError(UnknownCommandMsg & command, LineIndex, 1)
   EndIf
EndSub

Function FixBool(strValue)
   strValue = strValue.Replace("True", _True)
   Return strValue.Replace("False", _False)
EndFunction

Sub ProcessExitLoop(line)
   If Stack.GetCount(WhileStack) > 0 Then
      lastWhile = Stack.PeekValue(WhileStack)
      lastWhileLine = lastWhile[1]
   Else
      lastWhileLine = 0
   EndIf
   
   If Stack.GetCount(ForStack) > 0 Then
      lastFor = Stack.PeekValue(ForStack)
      lastForLine = lastFor[4]
   Else
      lastForLine = 0
   EndIf
   
   If lastWhileLine > lastForLine Then
      LineIndex = lastWhile[2]
      Stack.PopValue(WhileStack)
      
   ElseIf lastForLine > 0 Then
      LineIndex = lastFor[5]
      Stack.PopValue(ForStack)
   Else
      ReportError("لا توجد حلقة مفتوحة للخروج منها.", line, 1)
   EndIf
EndSub

Sub ProcessForLoopHeader()
   tokensCount = Tokens.Count
   If tokensCount < 6 Then
      ReportError("صيغة حلقة التكرار 'من.. إلى' أقصر من اللازم", LineIndex, 1)
      Return
   EndIf
   
   varName = Tokens[2][3]
   If IsValidVarName(varName, LineIndex, 2) = False Then
      Return
   EndIf
   
   If Tokens[3][3] <> "=" Then
      ReportError("من المفروض وجود العلامة = هنا", LineIndex, 3)
      Return
   EndIf
   
   result = EvaluateExpression(4)
   startValue = result[1]
   nextPos = result[2]
   nextToken = Tokens[nextPos][3]
   
   If nextToken <> _To1 And nextToken <> _To2 Then
      ReportError("من المفروض وجود الكلمة '" & _To1 & "' هنا", LineIndex, nextPos)
      Return
   EndIf
   
   result = EvaluateExpression(nextPos + 1)
   endValue = result[1]
   stepValue = 1
   nextPos = result[2]
   
   If nextPos <= tokensCount Then
      nextToken = Tokens[nextPos][3]
      If nextToken <> _Step Then
         ReportError("من المفروض وجود الكلمة '" & _Step & "' هنا", LineIndex, nextPos)
         Return
      EndIf
      
      If nextPos = tokensCount Then
         ReportError("مقدار الزيادة مفقود", LineIndex, nextPos)
         Return
      EndIf
      
      result = EvaluateExpression(nextPos + 1)
      nextPos = result[2]
      If nextPos <= tokensCount Then
         ReportError("'" & Tokens[nextPos][3] & "' غير متوقعة هنا", LineIndex, nextPos)
         Return
      EndIf
      stepValue = result[1]
   EndIf
   
   nextLineIndex = FindClosingToken(_For, _Next, LineIndex + 1)
   If nextLineIndex = 0 Then
      ReportError("'" & _Next & " " & varName & "' مفقودة", LineIndex, 1)
   Else
      Vars[varName] = startValue
      If stepValue > 0 Then
         If startValue > endValue Then
            LineIndex = nextLineIndex
            Return
         EndIf
      ElseIf startValue < endValue Then
         LineIndex = nextLineIndex
         Return
      EndIf
      
      loopObj = {varName, endValue, stepValue, LineIndex, nextLineIndex}
      Stack.PushValue(ForStack, loopObj)
   EndIf
EndSub

Function IsValidVarName(name, line, tokenIndex)
   If Text.IsNumeric(name[1]) Then
      ReportError("الاسم '" & name & "' لا يصلح كاسم متغير لأنه يبدأ برقم", line, tokenIndex)
      Return False
   ElseIf name = "_" Then
      ReportError("العلامة _ لا تصلح بمفردها كاسم متغير، لكن يمكن أن تستخدم ضصمن اسم متغير", line, tokenIndex)
      Return False
   Else
      ForEach c In name
         If (c = "_" Or Chars.IsDigit(c) Or Chars.IsLetter(c)) = False Then
            ReportError("الاسم '" & name & "' لا يصلح كاسم متغير بسبب وجود الرمز '" & c & "'", line, tokenIndex)
            Return False
         EndIf
      Next
   EndIf
   
   Return True
EndFunction

Function IsValidVarName2(name)
   If name = _And Or Text.IsNumeric(name[1]) Then
      Return False
   Else
      ForEach c In name
         If (c = "_" Or Chars.IsDigit(c) Or Chars.IsLetter(c)) = False Then
            Return False
         EndIf
      Next
   EndIf
   
   Return True
EndFunction

Sub ProcessForLoopNext()
   varName = Tokens[2][3]
   If Stack.GetCount(ForStack) = 0 Then
      ReportError("لا توجد حلقة تكرار مفتوحة", LineIndex, 1)
      Return
   EndIf
   
   loopObj = Stack.PeekValue(ForStack)
   If loopObj[1] <> varName Then
      ReportError("اسم العداد '" & varName & "' غير صحيح:" & Text.NewLine &
         "يجب أن تستخدم '" & loopObj[1] & "'", LineIndex, 2)
      Return
   EndIf
   
   end = loopObj[2]
   stepValue = loopObj[3]
   newVal = Vars[varName] + stepValue
   Vars[varName] = newVal
   
   If (stepValue > 0 And newVal <= end) Or
         (stepValue < 0 And newVal >= end) Then
      LineIndex = loopObj[4] ' loop
   Else
      Stack.PopValue(ForStack)
   EndIf
EndSub

Sub ProcessWhileLoopHeader()
   result = EvaluateExpression(2)
   nextPos = result[2]
   If nextPos < Tokens.Count Then
      ReportError("'" & Tokens[nextPos][3] & "' غير متوقعة هنا", LineIndex, nextPos)
      Return
   EndIf
   
   wendLineIndex = FindClosingToken(_While, _Wend, LineIndex + 1)
   If wendLineIndex = 0 Then
      ReportError("'" & _Wend & "' مفقودة", LineIndex, 1)
      Return
   EndIf
   
   condition = result[1]
   If condition Then
      Stack.PushValue(WhileStack, {LineIndex, wendLineIndex})
   Else
      lineId = LineIndex
      LineIndex = FindClosingToken(_While, _Wend, LineIndex + 1)
      If LineIndex = 0 Then
         ReportError("'" & _Wend & "' غير موجودة", lineId, 1)
      EndIf
   EndIf
EndSub

Sub ProcessWhileLoopEnd()
   If Stack.GetCount(WhileStack) = 0 Then
      ReportError("لا توجد حلقة تكرار مفتوحة", LineIndex, 1)
      Return
   EndIf
   
   lastWhile = Stack.PeekValue(WhileStack)
   whileLinIndex = lastWhile[1]
   Tokenize(Statements[whileLinIndex], whileLinIndex, _CommentSymbol)
   result = EvaluateExpression(2)
   
   If result[1] Then ' Condition is true
      LineIndex = whileLinIndex ' Jump up to the while header
   Else
      Stack.PopValue(WhileStack) ' Do nothing, and just move on to the line next to Wend
   EndIf
EndSub

Sub ProcessIfBlock()
   tokensCount = Tokens.Count
   endIfLineIndex = FindClosingToken(_If, _EndIf, LineIndex + 1)
   If endIfLineIndex = 0 Then
      ReportError("'" & _EndIf & "' مفقودة", LineIndex, 1)
      Return
   EndIf
   
   result = EvaluateExpression(2)
   nextPos = result[2]
   If nextPos < Tokens.Count Then
      ReportError("'" & Tokens[nextPos][3] & "' غير متوقعة هنا", LineIndex, nextPos)
      Return
   EndIf
   
   If result[1] Then ' Execute If Then branch
      LineIndex = LineIndex + 1
      While LineIndex <= Statements.Count
         Tokenize(Statements[LineIndex], LineIndex, _CommentSymbol)
         If tokensCount > 0 Then
            tokenFirst = Tokens[1][3]
            If tokenFirst = _EndIf Then
               Return
            ElseIf tokenFirst = _ElseIf Or tokenFirst = _Else Then
               ExitLoop
            EndIf
            
            ExecuteLine()
            ' The condition covers thee case of jumbing over EndIf like when using ExitLoop
            If LineIndex > endIfLineIndex Then
               Return
            EndIf
         EndIf
         LineIndex = LineIndex + 1
      Wend
      
      LineIndex = endIfLineIndex
      Return
   EndIf
   
   While True
      LineIndex = FindNextIfBranch(LineIndex + 1)
      Tokenize(Statements[LineIndex], LineIndex, _CommentSymbol)
      branchToken = Tokens[1][3]
      
      If branchToken <> _ElseIf Then
         ExitLoop
      EndIf
      
      result = EvaluateExpression(2)
      nextPos = result[2]
      If nextPos < Tokens.Count Then
         ReportError("'" & Tokens[nextPos][3] & "' غير متوقعة هنا", LineIndex, nextPos)
         Return
      EndIf
      
      If result[1] Then ' Execute elseIf block
         LineIndex = LineIndex + 1
         While LineIndex <= Statements.Count
            Tokenize(Statements[LineIndex], LineIndex, _CommentSymbol)
            If tokensCount > 0 Then
               tokenFirst = Tokens[1][3]
               If tokenFirst = _EndIf Then
                  Return
               ElseIf tokenFirst = _ElseIf Or tokenFirst = _Else Then
                  ExitLoop
               EndIf
               
               ExecuteLine()
               If LineIndex > endIfLineIndex Then
                  Return
               EndIf
            EndIf
            LineIndex = LineIndex + 1
         Wend
         
         LineIndex = endIfLineIndex
         Return
      EndIf
   Wend
   
   If branchToken = _Else Then
      LineIndex = LineIndex + 1
      While LineIndex <= Statements.Count
         Tokenize(Statements[LineIndex], LineIndex, _CommentSymbol)
         If tokensCount > 0 Then
            If Tokens[1][3] = _EndIf Then
               Return
            EndIf
            
            ExecuteLine()
            If LineIndex > endIfLineIndex Then
               Return
            EndIf
         EndIf
         LineIndex = LineIndex + 1
      Wend
   EndIf
   
EndSub

Function FindClosingToken(openToken, closeToken, startLine)
   nestingLevel = 0
   For i = startLine To Statements.Count
      statement = Text.Trim(Statements[i])
      If StartsWithToken(statement, openToken) Then
         nestingLevel = nestingLevel + 1
      ElseIf StartsWithToken(statement, closeToken) Then
         If nestingLevel = 0 Then
            Return i
         Else
            nestingLevel = nestingLevel - 1
         EndIf
         
         ' Next conditions prevents messed up blocks
      ElseIf StartsWithToken(statement, _If) Then ' Works only with While and For
         i = FindClosingToken(_If, _EndIf, i + 1)
         If i = 0 Then
            Return 0
         EndIf
      ElseIf StartsWithToken(statement, _While) Then ' Works only with If and For
         i = FindClosingToken(_While, _Wend, i + 1)
         If i = 0 Then
            Return 0
         EndIf
      ElseIf StartsWithToken(statement, _For) Then ' Works only with If and while
         i = FindClosingToken(_For, _Next, i + 1)
         If i = 0 Then
            Return 0
         EndIf
      ElseIf StartsWithToken(statement, _EndIf)
            Or StartsWithToken(statement, _Wend)
            Or StartsWithToken(statement, _Next) Then
         Return 0
      EndIf
   Next
   Return 0
EndFunction


Function FindNextIfBranch(startLine)
   nestingLevel = 0
   For i = startLine To Statements.Count
      statement = Text.Trim(Statements[i])
      If StartsWithToken(statement, _If) Then
         nestingLevel = nestingLevel + 1
      ElseIf StartsWithToken(statement, _EndIf) Then
         If nestingLevel = 0 Then
            Return i
         Else
            nestingLevel = nestingLevel - 1
         EndIf
      ElseIf nestingLevel = 0 Then
         If StartsWithToken(statement, _ElseIf) Or StartsWithToken(statement, _Else) Then
            Return i
         EndIf
      EndIf
   Next
   
   Return 0
EndFunction

Function StartsWithToken(statement, token)
   If Text.StartsWith(statement, token) = False Then
      Return False
   ElseIf statement = token Then
      Return True
   EndIf
   
   nextChar = statement[Text.GetLength(token) + 1]
   Return (nextChar = "_" Or Chars.IsDigit(nextChar) Or Chars.IsLetter(nextChar)) = False
EndFunction

Function EvaluateExpression(start)
   result = ParseExpression(start)
   nextPos = result[2]
   nextWord = Text.Trim(Tokens[nextPos][3])
   
   If nextWord[1] = _CommentSymbol Then
      Return {result[1], nextPos + 1}
   Else
      Return result
   EndIf
EndFunction

Function ParseExpression(pos)
   Return ParseOr(pos)
EndFunction

Function ParseOr(pos)
   arr = ParseAnd(pos)
   result = arr[1]
   pos = arr[2]
   tokensCount = Tokens.Count
   
   While pos <= tokensCount And Tokens[pos][3] = _Or
      pos = pos + 1
      arr2 = ParseAnd(pos)
      result = (result Or arr2[1])
      pos = arr2[2]
   Wend
   Return {result, pos}
EndFunction

Function ParseAnd(pos)
   arr = ParseComparison(pos)
   result = arr[1]
   pos = arr[2]
   tokensCount = Tokens.Count
   
   While pos <= tokensCount And Tokens[pos][3] = _And
      pos = pos + 1
      arr2 = ParseComparison(pos)
      result = (result And arr2[1])
      pos = arr2[2]
   Wend
   Return {result, pos}
EndFunction

Function ParseComparison(pos)
   arr = ParseAddExpr(pos)
   result = arr[1]
   pos = arr[2]
   
   If pos <= Tokens.Count Then
      op = Tokens[pos][3]
      If pos <> "" And (op = "<" Or op = ">" Or op = "=") Then
         nextOp = Tokens[pos + 1][3]
         If nextOp = "=" Or nextOp = ">" Then
            pos = pos + 2
         Else
            pos = pos + 1
         EndIf
         
         arr2 = ParseAddExpr(pos)
         right = arr2[1]
         pos = arr2[2]
         
         If op = "<" Then
            If nextOp = "=" Then
               result = result <= right
            ElseIf nextOp = ">" Then
               result = result <> right
            Else
               result = result < right
            EndIf
            
         ElseIf op = ">" Then
            If nextOp = "=" Then
               result = result >= right
            Else
               result = result > right
            EndIf
         Else
            result = (result = right)
         EndIf
      EndIf
   EndIf
   Return {result, pos}
EndFunction

Function ParseAddExpr(pos)
   arr = ParseTerm(pos)
   leftValue = arr[1]
   pos = arr[2]
   op = Tokens[pos][3]
   tokensCount = Tokens.Count
   
   While pos <= tokensCount And (op = "+" Or op = "-")
      pos = pos + 1
      arr2 = ParseTerm(pos)
      rightValue = arr2[1]
      
      If op = "+" Then
         leftValue = leftValue + rightValue
      Else
         leftValue = leftValue - rightValue
      EndIf
      
      pos = arr2[2]
      op = Tokens[pos][3]
   Wend
   Return {leftValue, pos}
EndFunction

Function ParsePower(pos)
   arr = ParseFactor(pos)
   leftValue = arr[1]
   pos = arr[2]
   op = Text.Trim(Tokens[pos][3])
   tokensCount = Tokens.Count
   
   If op[1] = _CommentSymbol Then
      Return {leftValue, pos}
      
   ElseIf op <> "" Then
      If Opertors.ContainsValue(op) = False And BasicWords.ContainsValue(op) = False Then
         ReportError("المعامل '" & op & "' غير معروف", LineIndex, pos)
         Return {leftValue, pos}
      EndIf
      
      If pos = tokensCount And op <> ")" Then
         ReportError("الحد الثاني للعملية مفقود", LineIndex, pos)
         Return {leftValue, pos}
      EndIf
   EndIf
   
   While pos <= tokensCount And op = "^"
      pos = pos + 1
      arr2 = ParseFactor(pos)
      rightValue = arr2[1]
      leftValue = Math.Power(leftValue, rightValue)
      pos = arr2[2]
      op = Tokens[pos][3]
   Wend
   
   Return {leftValue, pos}
EndFunction

Function ParseTerm(pos)
   arr = ParsePower(pos)
   leftValue = arr[1]
   pos = arr[2]
   op = Text.Trim(Tokens[pos][3])
   tokensCount = Tokens.Count
   
   While pos <= tokensCount And (
         op = "*" Or op = "×" Or op = "/" Or op = _IntegralDivision Or op = "%" Or op = "^"
      )
      pos = pos + 1
      arr2 = ParsePower(pos)
      rightValue = arr2[1]
      
      If op = "*" Or op = "×" Then
         leftValue = leftValue * rightValue
      ElseIf op = "/" Then
         leftValue = leftValue / rightValue
      ElseIf op = _IntegralDivision Then
         leftValue = Math.Truncate(leftValue / rightValue)
      Else
         leftValue = leftValue Mod rightValue
      EndIf
      
      pos = arr2[2]
      op = Tokens[pos][3]
   Wend
   
   Return {leftValue, pos}
EndFunction

Function ParseFactor(pos)
   If TW.IsClosed Then
      Return {}
   EndIf
   
   token = Text.Trim(Tokens[pos][3])
   tokensCount = Tokens.Count
   
   If token = "" Or token[1] = _CommentSymbol Then
      ReportError("الحد الثاني للعملية مفقود", LineIndex, pos)
      
   ElseIf token = _True Then
      Return {True, pos + 1}
      
   ElseIf token = _False Then
      Return {False, pos + 1}
      
   ElseIf token = "(" Then
      wordID = pos
      pos = pos + 1
      arr = ParseExpression(pos)
      result = arr[1]
      pos = arr[2]
      If pos <= tokensCount And Tokens[pos][3] = ")" Then
         pos = pos + 1
      Else
         ReportError("قوس الإغلاق مفقود", LineIndex, wordID)
      EndIf
      Return {result, pos}
      
   ElseIf token = _Random Then
      Return {Math.GetRandomNumber(100), pos + 1}
      
   ElseIf token = _Read Then
      pos = pos + 1
      If pos <= tokensCount Then
         nextToken = Tokens[pos][3]
         If nextToken = _Text1 Or nextToken = _Text2 Then
            value = TextWindow.Read()
            Return {value, pos + 1}
         ElseIf nextToken = _Number1 Or nextToken = _Number2 Then
            value = TextWindow.ReadNumber()
            pos = pos + 1
            Return {value, pos}
         EndIf
      EndIf
      Return {0, pos}
      
   ElseIf Text.IsNumeric(token) Then
      Return {token, pos + 1}
      
   ElseIf Text.StartsWith(token, """") And Text.EndsWith(token, """") Then
      Return {Text.GetSubText(token, 2, Text.GetLength(token) - 2), pos + 1}
      
   ElseIf Vars.ContainsIndex(token) Then
      Return {Vars[token], pos + 1}
      
   ElseIf Opertors.ContainsValue(token) Then
      ReportError(" لا يمكن استخدام المعامل '" & token & "' في هذا الموضغ", LineIndex, pos)
      
   ElseIf BasicWords.ContainsValue(token) Then
      ReportError("الكلمة '" & token & "' هي كلمة أساسية ولا يمكن استخدامها في هذا الموضع", LineIndex, pos)
      
   Else
      ReportError("الكلمة '" & token & "' غير معروفة", LineIndex, pos)
   EndIf
   
   Return {0, pos + 1}
EndFunction

Sub ReportError(msg, line, tokenIndex)
   If Terminated Then
      Return
   EndIf
   
   Terminated = True
   code = EditorTextBox.Text
   token = Tokens[tokenIndex]
   
   pos = 0
   For i = 1 To line - 1
      pos = code.IndexOf(Chars.Lf, pos + 1, False)
   Next
   pos = pos + token[2]
   
   EditorTextBox.Focus()
   EditorTextBox.CaretIndex = pos
   EditorTextBox.Select(pos, Text.GetLength(token[3]))
   
   If TW.IsClosed = False Then
      Terminate(
         Array.Join(
            {
               "خطأ عند الكلمة رقم ", tokenIndex,
               " في السطر رقم ", line, ":",
               Chars.Lf, msg,
               Chars.Lf, ProEndMsg
            },
            ""
         ), True
      )
   EndIf
EndSub

IndentLevel = 0

Sub IndentCode()
   originalText = EditorTextBox.Text
   normalizedText = originalText.Replace(Chars.CrLf, Chars.Lf)
   Statements = normalizedText.Split(Chars.Lf, False, False)
   statementsCount = Statements.Count
   
   IndentLevel = 0
   code = ""
   caretPos = EditorTextBox.CaretIndex
   caretDelta = 0
   newCaretPos = 0
   currentLineStart = 1
   caretLineIndex = 0
   cumulativeDelta = 0
   
   For lineIndex = 1 To statementsCount
      origLine = Statements[lineIndex]
      origLen = Text.GetLength(origLine)
      
      caretColumn = 0
      If (caretPos >= currentLineStart) And (caretPos <= currentLineStart + origLen) Then
         caretColumn = caretPos - currentLineStart + 1
         caretLineIndex = lineIndex
      EndIf
      
      Tokenize(Text.Trim(origLine), lineIndex, _CommentSymbol)
      
      If Tokens.Count > 0 Then
         formattedLine = IndentLine()
      ElseIf lineIndex Then
         formattedLine = Text.Repeat(" ", IndentLevel)
      EndIf
      
      formattedLen = Text.GetLength(formattedLine)
      
      If caretLineIndex = 0 Then
         cumulativeDelta = cumulativeDelta + formattedLen - origLen
      ElseIf lineIndex = caretLineIndex Then
         nonSpaces = 0
         preserveSpaces = 0
         For i = caretColumn To 1 Step -1
            If origLine[i] <> " " Then
               nonSpaces = nonSpaces + 1
            ElseIf nonSpaces = 0 Then
               preserveSpaces = preserveSpaces + 1
            EndIf
         Next
         
         n = 0
         For i = 1 To formattedLen
            If formattedLine[i] <> " " Then
               n = n + 1
               If n = nonSpaces Then
                  extra = 0
                  For j = 1 To preserveSpaces
                     If formattedLine[i + j] = " " Then
                        extra = extra + 1
                     Else
                        ExitLoop
                     EndIf
                  Next
                  
                  cumulativeDelta = cumulativeDelta + i - caretColumn + extra
                  ExitLoop
               EndIf
            EndIf
         Next
      EndIf
      
      
      If lineIndex < statementsCount Then
         code = code & formattedLine & Text.NewLine
      Else
         code = code & formattedLine
      EndIf
      
      currentLineStart = currentLineStart + origLen + 2
   Next
   
   newCaretPos = caretPos + cumulativeDelta
   EditorTextBox.Text = code
   EditorTextBox.CaretIndex = newCaretPos
   _ColoringRequested = True
EndSub


Function IndentLine()
   currentWord = ""
   tokensCount = Tokens.Count
   
   ' Adjust Arabic syntax for writting an empty line
   removeEmptyString = (tokensCount = 3 And Tokens[3][3] = """""")
   writeTheLine = (Tokens[1][3] = _Write And Tokens[2][3] = _Line2)
   If writeTheLine And (tokensCount = 2 Or removeEmptyString) Then
      tokensCount = 2
      Tokens[2][3] = _Line1
   EndIf
   
   lineText = ""
   indent = Text.Repeat(" ", IndentLevel)
   
   For i = 1 To tokensCount
      sep = ""
      If i < tokensCount Then
         word = Text.Trim(Tokens[i + 1][3])
         If word[1] <> _CommentSymbol Then
            sep = " "
         EndIf
      EndIf
      
      currentWord = Tokens[i][3]
      If currentWord[1] = """" Then
         If Text.EndsWith(currentWord, """") Then
            lineText = lineText & currentWord & sep
         Else
            lineText = lineText & currentWord & """" & sep
         EndIf
         
      ElseIf currentWord.IsNumeric Then
         lineText = lineText & currentWord & sep
         
      ElseIf BasicWords.ContainsValue(currentWord) Then
         prevWord = Tokens[i - 1]
         If (currentWord = _Number2 And prevWord <> _Read)
               Or (currentWord = _Line2 And prevWord <> _Write) Then
            lineText = lineText & currentWord & sep
         Else
            lineText = lineText & currentWord & sep
            If i = 1 And IndentLevel > 0 Then
               If currentWord = _ElseIf Or currentWord = _Else Then
                  indent = Text.Repeat(" ", IndentLevel - 4)
               ElseIf currentWord = _EndIf Or currentWord = _Next Or currentWord = _Wend Then
                  IndentLevel = IndentLevel - 4
                  indent = Text.Repeat(" ", IndentLevel)
               EndIf
            EndIf
         EndIf
         
         If currentWord = _If Or currentWord = _While Or currentWord = _For Then
            IndentLevel = IndentLevel + 4
            If i = tokensCount Then
               lineText = lineText & " "
            EndIf
         EndIf
         
      Else
         lineText = lineText & currentWord & sep
      EndIf
   Next
   
   Return indent & lineText
EndFunction


Sub ManageCodeColoring()
   If _StillColoring = False And _ColoringRequested Then
      ColorCode()
   EndIf
EndSub

Sub ColorCode()
   Timer.Pause()
   _ColoringRequested = False
   _StillColoring = True
   _DoColorCode(LblFormat, EditorTextBox.Text)
   _StillColoring = False
   Timer.Resume()
EndSub

Sub ColorLine(inputText)
   _DoColorCode(LblLine, inputText)
EndSub

Sub _DoColorCode(targetLabel, code)
   ' The extra space ensures formatting the last word.
   ' This extra speca is added to the label only, so it doesn't appear in the txtEditor!
   ' So it doesn't affect the original code!
   inputText = code + " "
   If inputText = targetLabel.Text Then
      Return
   EndIf
   
   targetLabel.Visible = False
   targetLabel.Text = ""
   textLength = inputText.Length
   prevWord = ""
   currentWord = ""
   normalText = ""
   currentString = ""
   
   For i = 1 To textLength
      c = inputText[i]
      
      If c = _CommentSymbol Or c = """" Or Opertors.ContainsValue(c) Then
         ' A new cooment or a string literal is starting.  Flush any pending word first.
         If currentWord <> "" Then
            If BasicWords.ContainsValue(currentWord) Then
               If normalText <> "" Then
                  targetLabel.Append(normalText)
                  normalText = ""
               EndIf
               
               If currentWord = _Number2 And prevWord <> _Read Then
                  normalText = currentWord
               ElseIf currentWord = _Line2 And prevWord <> _Write Then
                  normalText = currentWord
               Else
                  targetLabel.AppendFormatted(
                     currentWord, "", 0, True, False, False,
                     _KeywordsColor, Colors.None, "")
               EndIf
               
            ElseIf currentWord.IsNumeric Then
               If normalText <> "" Then
                  targetLabel.Append(normalText)
                  normalText = ""
               EndIf
               targetLabel.AppendWithForeColor(currentWord, "#FF0000")
            Else
               normalText = normalText & currentWord
            EndIf
            prevWord = currentWord
            currentWord = ""
         EndIf
         
         If normalText <> "" Then
            targetLabel.Append(normalText)
            normalText = ""
         EndIf
         
         lfPos = Text.IndexOf(inputText, Chars.Lf, i + 1, False)
         
         If c = _CommentSymbol Then
            If lfPos = 0 Then
               lfPos = textLength
            EndIf
            
            currentString = Text.GetSubText(inputText, i, lfPos - i + 1)
            targetLabel.AppendWithForeColor(currentString, "#FF008020")
            i = lfPos
            
         ElseIf c = """" Then
            qPos = Text.IndexOf(inputText, """", i + 1, False)
            
            If lfPos = 0 Then
               If qPos = 0 Then
                  qPos = textLength
               EndIf
            ElseIf qPos = 0 Or qPos > lfPos Then
               qPos = lfPos
            EndIf
            
            currentString = Text.GetSubText(inputText, i, qPos - i + 1)
            targetLabel.AppendWithForeColor(currentString, "#DF1111")
            i = qPos
            
         Else ' Operator
            targetLabel.AppendWithForeColor(c, "#800000")
         EndIf
         
      ElseIf c.IsDigit Or c.IsLetter Or c = "_" Or c = "." Then
         currentWord = currentWord & c
      Else
         ' Process any pending word when a non-word character is encountered.
         If currentWord <> "" Then
            If BasicWords.ContainsValue(currentWord) Then
               If normalText <> "" Then
                  targetLabel.Append(normalText)
                  normalText = ""
               EndIf
               
               If currentWord = _Number2 And prevWord <> _Read Then
                  normalText = currentWord
               ElseIf currentWord = _Line2 And prevWord <> _Write Then
                  normalText = currentWord
               Else
                  targetLabel.AppendFormatted(
                     currentWord, "", 0, True, False, False,
                     _KeywordsColor, Colors.None, "")
               EndIf
               
            ElseIf currentWord.IsNumeric Then
               If normalText <> "" Then
                  targetLabel.Append(normalText)
                  normalText = ""
               EndIf
               targetLabel.AppendWithForeColor(currentWord, "#FF0000")
            Else
               normalText = normalText & currentWord
            EndIf
            prevWord = currentWord
            currentWord = ""
         EndIf
         normalText = normalText & c
      EndIf
   Next
   
   If normalText <> "" Then
      targetLabel.Append(normalText)
   EndIf
   
   targetLabel.Visible = True
EndSub

Function AutoCompleteBlock()
   pos = EditorTextBox.CaretIndex
   If pos < 2 Then
      Return 0
   EndIf
   
   txt = EditorTextBox.Text
   lineEnd = txt.IndexOf(Chars.Lf, pos, False)
   If lineEnd = 0 Then
      lineEnd = txt.Length
   EndIf
   
   rest = txt.SubText(pos, lineEnd - pos)
   If Text.Trim(rest) <> "" Then
      Return 0
   EndIf
   
   lineStart = txt.IndexOf(Chars.Lf, pos - 1, True) + 1
   prev = txt.SubText(lineStart, pos - lineStart)
   If prev.EndsWith(" ") Then
      Return 0
   EndIf
   
   word = prev.Trim()
   spaces = Text.Repeat(" ", prev.Length - word.Length)
   
   If word = _If Then
      EditorTextBox.SelectedText = " " & "شرط " & Chars.CrLf
         & spaces & "    " & Chars.CrLf
         & spaces & _EndIf
      EditorTextBox.CaretIndex = pos + 1
      Return 3
      
   ElseIf word = _While Then
      EditorTextBox.SelectedText =
         " " & _True & Chars.CrLf
         & spaces & spaces & "    " & Chars.CrLf
         & spaces & _Wend
      EditorTextBox.CaretIndex = pos + 1
      Return _True.Length
      
   ElseIf word = _For Then
      forVar = GetForVar()
      EditorTextBox.SelectedText =
         " " & forVar & " = 1 " & _To1 & " 10" & Chars.CrLf
         & spaces & "    " & Chars.CrLf
         & spaces & _Next & " " & forVar
      EditorTextBox.CaretIndex = pos + 1
      Return 1
   EndIf
   
   Return 0
EndFunction

CounterNames = {"ن", "م", "ل", "ك", "و", "ي", "ت", "ج", "د"}

Function GetForVar()
   txt = EditorTextBox.Text
   ForEach name In CounterNames
      declaration = name & " ="
      If (txt.StartsWith(declaration)
            Or txt.Contains(Chars.Lf & declaration)
            Or txt.Contains(" " & declaration)
         ) = False Then
         declaration = name & "="
         If (txt.StartsWith(declaration)
               Or txt.Contains(Chars.Lf & declaration)
               Or txt.Contains(" " & declaration)
            ) = False Then
            Return name
         EndIf
      EndIf
   Next
EndFunction

Sub FixNextVarName(ixdex, lineText)
   forPos = lineText.IndexOf(_For, 1, False)
   If forPos = 0 Then
      Return
   EndIf
   
   Tokenize(lineText, 1, _CommentSymbol)
   varName = Tokens[2][3]
   If varName = "" Then
      Return
   EndIf
   
   code = Text.GetSubTextToEnd(EditorTextBox.Text, ixdex)
   Statements = Text.Split(code, Chars.Lf, False, False)
   nextLineIndex = FindClosingToken(_For, _Next, 2)
   If nextLineIndex = 0 Then
      Return
   EndIf
   
   Tokenize(Statements[nextLineIndex], nextLineIndex, _CommentSymbol)
   nextVarName = Tokens[2][3]
   
   If nextVarName <> varName Then
      lineStart = ixdex
      For i = 1 To nextLineIndex - 1
         lineStart = lineStart + Text.GetLength(Statements[i]) + 1
      Next
      
      caretPos = EditorTextBox.CaretIndex
      EditorTextBox.SelectionStart = lineStart + Tokens[2][2] - 1
      EditorTextBox.SelectionLength = Text.GetLength(nextVarName)
      EditorTextBox.SelectedText = varName
      EditorTextBox.CaretIndex = caretPos
   EndIf
EndSub

Function GetVarNames()
   code = EditorTextBox.Text
   end = code.IndexOf(Chars.Lf, EditorTextBox.CaretIndex, True)
   If end = 0 Then
      Return {}
   EndIf
   
   lines = Text.Split(code.SubText(1, end - 1), Chars.Lf, True, True)
   Vars = {}
   
   ForEach line In lines
      If Text.StartsWith(line, _For & " ") Then
         line = Text.GetSubTextToEnd(line, _For.Length + 2)
      EndIf
      
      pos = Text.IndexOf(line, "=", 1, False)
      If pos > 0 Then
         space = Text.IndexOf(line, " ", pos, True)
         If space = 0 Or space = pos - 1 Then
            varName = Text.Trim(Text.GetSubText(line, 1, space - 1))
            If varName <> "" And IsValidVarName2(varName)
                  And Vars.ContainsValue(varName) = False Then
               Vars.Append(varName)
            EndIf
         EndIf
      EndIf
   Next
   
   Return Vars
EndFunction


Function IsLiteralOrComment(pos)
   code = EditorTextBox.Text
   c = code[pos - 1]
   If c = "" Then
      Return False
   ElseIf c = Chars.Quote Then
      Return True
   EndIf
   
   start = code.IndexOf(Chars.Lf, pos, True) + 1
   end = code.IndexOf(Chars.Lf, pos, False)
   If end = 0 Then
      end = code.Length + 1
   EndIf
   
   line = code.SubText(start, end - start)
   col = pos - start + 1
   Tokenize(line, 1, _CommentSymbol)
   
   ForEach token In Tokens
      start = token[2]
      tokenText = Text.Trim(token[3])
      end = start + tokenText.Length - 1
      
      If col >= start And col <= end Then
         If tokenText.IsNumeric Or tokenText[1] = Chars.Quote
               Or tokenText[1] = _CommentSymbol Then
            Return True
         EndIf
      EndIf
   Next
   
   Return False
EndFunction

Sub SaveSettings(ops)
   If File.WriteContents(_SettingsFile, ops) = 0 Then
      Forms.ShowMessage(File.LastError, "Error")
      Return
   EndIf
EndSub


' ==========Shala to Small Visual Basic Converter ==========


ConvertToEnSahla = False
LettersMap = {}

' For converting your native code to Engkish sahla. Don't change these tokens:
_EnTrue = "True"
_EnFalse = "False"
_EnIf = "If"
_EnElseIf = "ElseIf"
_EnElse = "Else"
_EnEndIf = "EndIf"
_EnAnd = "And"
_EnOr = "Or"
_EnWhile = "While"
_EnWend = "Wend"
_EnFor = "For"
_EnTo1 = "To"
_EnTo2 = "To2"
_EnStep = "Step"
_EnNext = "Next"
_EnExitLoop = "Exit"
_EnWrite = "Write"
_EnLine1 = "Line"
_EnLine2 = "Line2"
_EnRead = "Read"
_EnText1 = "Text"
_EnText2 = "Text2"
_EnNumber1 = "Number"
_EnNumber2 = "Number2"
_EnRandom = "Random"
_EnWait = "Wait"
_EnSound = "Play"
_EnBeep = "Beep"
_EnBell = "Bell"
_EnDing = "Ding"
_EnClick = "Click"
_EnChime = "Chime"
_EnIntegralDivision = "\"
_EnCommmentSymbol = "'"

OrgTokes = {}
DestTokes = {}


Sub InitTransTokes(forwardConversion)
   If forwardConversion Then
      OrgTokes[_EnTrue] = _True
      DestTokes[_EnTrue] = _EnTrue
      
      OrgTokes[_EnFalse] = _False
      DestTokes[_EnFalse] = _EnFalse
      
      OrgTokes[_EnIf] = _If
      DestTokes[_EnIf] = _EnIf
      
      OrgTokes[_EnElseIf] = _ElseIf
      DestTokes[_EnElseIf] = _EnElseIf
      
      OrgTokes[_EnElse] = _Else
      DestTokes[_EnElse] = _EnElse
      
      OrgTokes[_EnEndIf] = _EndIf
      DestTokes[_EnEndIf] = _EnEndIf
      
      OrgTokes[_EnAnd] = _And
      DestTokes[_EnAnd] = _EnAnd
      
      OrgTokes[_EnOr] = _Or
      DestTokes[_EnOr] = _EnOr
      
      OrgTokes[_EnWhile] = _While
      DestTokes[_EnWhile] = _EnWhile
      
      OrgTokes[_EnWend] = _Wend
      DestTokes[_EnWend] = _EnWend
      
      OrgTokes[_EnFor] = _For
      DestTokes[_EnFor] = _EnFor
      
      OrgTokes[_EnTo1] = _To1
      OrgTokes[_EnTo2] = _To2
      DestTokes[_EnTo1] = _EnTo1
      
      OrgTokes[_EnStep] = _Step
      DestTokes[_EnStep] = _EnStep
      
      OrgTokes[_EnNext] = _Next
      DestTokes[_EnNext] = _EnNext
      
      OrgTokes[_EnExitLoop] = _ExitLoop
      DestTokes[_EnExitLoop] = _EnExitLoop
      
      OrgTokes[_EnWrite] = _Write
      DestTokes[_EnWrite] = _EnWrite
      
      OrgTokes[_EnLine1] = _Line1
      OrgTokes[_EnLine2] = _Line2
      DestTokes[_EnLine1] = _EnLine1
      
      OrgTokes[_EnRead] = _Read
      DestTokes[_EnRead] = _EnRead
      
      OrgTokes[_EnText1] = _Text1
      OrgTokes[_EnText2] = _Text2
      DestTokes[_EnText1] = _EnText1
      
      OrgTokes[_EnNumber1] = _Number1
      OrgTokes[_EnNumber2] = _Number2
      DestTokes[_EnNumber1] = _EnNumber1
      
      OrgTokes[_EnRandom] = _Random
      DestTokes[_EnRandom] = _EnRandom
      
      OrgTokes[_EnWait] = _Wait
      DestTokes[_EnWait] = _EnWait
      
      OrgTokes[_EnSound] = _Sound
      DestTokes[_EnSound] = _EnSound
      
      OrgTokes[_EnBeep] = _Beep
      DestTokes[_EnBeep] = _EnBeep
      
      OrgTokes[_EnBell] = _Bell
      DestTokes[_EnBell] = _EnBell
      
      OrgTokes[_EnDing] = _Ding
      DestTokes[_EnDing] = _EnDing
      
      OrgTokes[_EnClick] = _Click
      DestTokes[_EnClick] = _EnClick
      
      OrgTokes[_EnChime] = _Chime
      DestTokes[_EnChime] = _EnChime
      
      OrgTokes[_EnIntegralDivision] = _IntegralDivision
      DestTokes[_EnIntegralDivision] = _EnIntegralDivision
      
      OrgTokes[_EnCommmentSymbol] = _CommentSymbol
      DestTokes[_EnCommmentSymbol] = _EnCommmentSymbol
      
   Else
      ' Reverse conversion: English → native.
      OrgTokes[_EnTrue] = _EnTrue
      DestTokes[_EnTrue] = _True
      
      OrgTokes[_EnFalse] = _EnFalse
      DestTokes[_EnFalse] = _False
      
      OrgTokes[_EnIf] = _EnIf
      DestTokes[_EnIf] = _If
      
      OrgTokes[_EnElseIf] = _EnElseIf
      DestTokes[_EnElseIf] = _ElseIf
      
      OrgTokes[_EnElse] = _EnElse
      DestTokes[_EnElse] = _Else
      
      OrgTokes[_EnEndIf] = _EnEndIf
      DestTokes[_EnEndIf] = _EndIf
      
      OrgTokes[_EnAnd] = _EnAnd
      DestTokes[_EnAnd] = _And
      
      OrgTokes[_EnOr] = _EnOr
      DestTokes[_EnOr] = _Or
      
      OrgTokes[_EnWhile] = _EnWhile
      DestTokes[_EnWhile] = _While
      
      OrgTokes[_EnWend] = _EnWend
      DestTokes[_EnWend] = _Wend
      
      OrgTokes[_EnFor] = _EnFor
      DestTokes[_EnFor] = _For
      
      OrgTokes[_EnTo1] = _EnTo1
      OrgTokes[_EnTo2] = _EnTo1
      DestTokes[_EnTo1] = _To1
      
      OrgTokes[_EnStep] = _EnStep
      DestTokes[_EnStep] = _Step
      
      OrgTokes[_EnNext] = _EnNext
      DestTokes[_EnNext] = _Next
      
      OrgTokes[_EnExitLoop] = _EnExitLoop
      DestTokes[_EnExitLoop] = _ExitLoop
      
      OrgTokes[_EnWrite] = _EnWrite
      DestTokes[_EnWrite] = _Write
      
      OrgTokes[_EnLine1] = _EnLine1
      OrgTokes[_EnLine2] = _EnLine1
      DestTokes[_EnLine1] = _Line2
      
      OrgTokes[_EnRead] = _EnRead
      DestTokes[_EnRead] = _Read
      
      OrgTokes[_EnText1] = _EnText1
      OrgTokes[_EnText2] = _EnText1
      DestTokes[_EnText1] = _Text1
      
      OrgTokes[_EnNumber1] = _EnNumber1
      OrgTokes[_EnNumber2] = _EnNumber1
      DestTokes[_EnNumber1] = _Number1
      
      OrgTokes[_EnRandom] = _EnRandom
      DestTokes[_EnRandom] = _Random
      
      OrgTokes[_EnWait] = _EnWait
      DestTokes[_EnWait] = _Wait
      
      OrgTokes[_EnSound] = _EnSound
      DestTokes[_EnSound] = _Sound
      
      OrgTokes[_EnBeep] = _EnBeep
      DestTokes[_EnBeep] = _Beep
      
      OrgTokes[_EnBell] = _EnBell
      DestTokes[_EnBell] = _Bell
      
      OrgTokes[_EnDing] = _EnDing
      DestTokes[_EnDing] = _Ding
      
      OrgTokes[_EnClick] = _EnClick
      DestTokes[_EnClick] = _Click
      
      OrgTokes[_EnChime] = _EnChime
      DestTokes[_EnChime] = _Chime
      
      OrgTokes[_EnIntegralDivision] = _EnIntegralDivision
      DestTokes[_EnIntegralDivision] = _IntegralDivision
      
      OrgTokes[_EnCommmentSymbol] = _EnCommmentSymbol
      DestTokes[_EnCommmentSymbol] = _CommentSymbol
   EndIf
EndSub

Function ConvertToNativeSahlaCode(enCode)
   Return _ConvertSahlaCode(enCode, True, False)
EndFunction

Function ConvertSahlaCode(toEnSahla)
   code = Text.Replace(EditorTextBox.Text, Chars.CrLf, Chars.Lf)
   Return _ConvertSahlaCode(code, toEnSahla, True)
EndFunction


Function _ConvertSahlaCode(code, toEnSahla, forwardConversion)
   ConvertToEnSahla = toEnSahla
   InitTransTokes(forwardConversion)
   MapLetters(forwardConversion)
   
   Vars = {}
   Statements = Text.Split(code, Chars.Lf, False, False)
   LineIndex = 1
   sVBLines = {}
   
   ForEach statement In Statements
      indentLength = 0
      ForEach c In statement
         If c = " " Then
            indentLength = indentLength + 1
         Else
            ExitLoop
         EndIf
      Next
      
      Tokenize(statement, LineIndex, OrgTokes[_EnCommmentSymbol])
      sVBLines.Append(Text.Repeat(" ", indentLength) & ConvertLine())
      LineIndex = LineIndex + 1
   Next
   
   Return sVBLines.Join(Chars.CrLf)
EndFunction

Sub MapLetters(forwardConversion)
   LettersMap = {}
   If forwardConversion Then
      LettersMap["ا"] = "a"
      LettersMap["أ"] = "a_"
      LettersMap["آ"] = "aa_"
      LettersMap["إ"] = "a1_"
      LettersMap["ء"] = "a2_"
      LettersMap["ئ"] = "a3_"
      LettersMap["ؤ"] = "a4_"
      LettersMap["ب"] = "b"
      LettersMap["ت"] = "t"
      LettersMap["ث"] = "th_"
      LettersMap["ج"] = "g"
      LettersMap["ح"] = "hh_"
      LettersMap["خ"] = "kh_"
      LettersMap["د"] = "d"
      LettersMap["ذ"] = "the_"
      LettersMap["ر"] = "r"
      LettersMap["ز"] = "z"
      LettersMap["س"] = "s"
      LettersMap["ش"] = "sh_"
      LettersMap["ص"] = "ss_"
      LettersMap["ض"] = "dh_"
      LettersMap["ط"] = "t1_"
      LettersMap["ظ"] = "zh_"
      LettersMap["ع"] = "_3_"
      LettersMap["غ"] = "gh_"
      LettersMap["ف"] = "f"
      LettersMap["ق"] = "q"
      LettersMap["ك"] = "k"
      LettersMap["ل"] = "l"
      LettersMap["م"] = "m"
      LettersMap["ن"] = "n"
      LettersMap["ه"] = "h"
      LettersMap["و"] = "o"
      LettersMap["ي"] = "y"
      LettersMap["ة"] = "t2_"
   Else
      LettersMap["ce"] = "س"
      LettersMap["ci"] = "س"
      LettersMap["cy"] = "س"
      LettersMap["ch"] = "ش"
      LettersMap["sh"] = "ش"
      LettersMap["ph"] = "ف"
      LettersMap["gh"] = "غ"
      LettersMap["th"] = "ذ"
      LettersMap["ie"] = "ي"
      LettersMap["ei"] = "ي"
      LettersMap["ea"] = "ي"
      LettersMap["ou"] = "و"
      LettersMap["ow"] = "و"
      
      LettersMap["a"] = "ا"
      LettersMap["b"] = "ب"
      LettersMap["c"] = "ك"
      LettersMap["d"] = "د"
      LettersMap["e"] = "ي"
      LettersMap["f"] = "ف"
      LettersMap["g"] = "ج"
      LettersMap["h"] = "ه"
      LettersMap["i"] = "ي"
      LettersMap["j"] = "ج"
      LettersMap["k"] = "ك"
      LettersMap["l"] = "ل"
      LettersMap["m"] = "م"
      LettersMap["n"] = "ن"
      LettersMap["o"] = "و"
      LettersMap["p"] = "ب"
      LettersMap["q"] = "ق"
      LettersMap["r"] = "ر"
      LettersMap["s"] = "س"
      LettersMap["t"] = "ت"
      LettersMap["u"] = "و"
      LettersMap["v"] = "ف"
      LettersMap["w"] = "و"
      LettersMap["x"] = "كس"
      LettersMap["y"] = "ي"
      LettersMap["z"] = "ز"
   EndIf
EndSub


Function ConvertLine()
   tokensCount = Tokens.Count
   command = Text.Trim(Tokens[1][3])
   
   If command[1] = OrgTokes[_EnCommmentSymbol] Then
      command[1] = DestTokes[_EnCommmentSymbol]
      Return command
      
   ElseIf Text.AreEquals(command, OrgTokes[_EnWait], False) Then
      If tokensCount = 1 Then
         If ConvertToEnSahla Then
            Return DestTokes[_EnWait]
         EndIf
         Return "Program.Delay(1000)"
      Else
         result = BuildExpressionText(2)
         If ConvertToEnSahla Then
            Return DestTokes[_EnWait] & " " & result[1]
         EndIf
         Return "Program.Delay(" & result[1] & ")"
      EndIf
      
   ElseIf Text.AreEquals(command, OrgTokes[_EnWrite], False) Then
      nextCommand = Tokens[2][3]
      If Text.AreEquals(nextCommand, OrgTokes[_EnLine1], False)
            Or Text.AreEquals(nextCommand, OrgTokes[_EnLine2], False) Then
         If tokensCount = 2 Then
            If ConvertToEnSahla Then
               Return DestTokes[_EnWrite] & " " & DestTokes[_EnLine1]
            EndIf
            Return "TW.WriteLine(\" \")"
         Else
            result = BuildExpressionText(3)
            If ConvertToEnSahla Then
               Return DestTokes[_EnWrite] & " " & DestTokes[_EnLine1] & " " & result[1]
            EndIf
            Return "TW.WriteLine(" & result[1] & ")"
         EndIf
      Else
         result = BuildExpressionText(2)
         If ConvertToEnSahla Then
            Return DestTokes[_EnWrite] & " " & result[1]
         EndIf
         Return "TW.Write(" & result[1] & ")"
      EndIf
      
   ElseIf Text.AreEquals(command, OrgTokes[_EnFor], False) Then
      Return ConvertForLoopHeader()
      
   ElseIf Text.AreEquals(command, OrgTokes[_EnNext], False) Then
      If ConvertToEnSahla Then
         Return DestTokes[_EnNext] & " " & Vars[Tokens[2][3]]
      EndIf
      Return DestTokes[_EnNext]
      
   ElseIf Text.AreEquals(command, OrgTokes[_EnWhile], False) Then
      result = BuildExpressionText(2)
      Return DestTokes[_EnWhile] & " " & result[1]
      
   ElseIf Text.AreEquals(command, OrgTokes[_EnWend], False) Then
      Return DestTokes[_EnWend]
      
   ElseIf Text.AreEquals(command, OrgTokes[_EnIf], False) Then
      result = BuildExpressionText(2)
      If ConvertToEnSahla Then
         Return DestTokes[_EnIf] & " " & result[1]
      EndIf
      Return DestTokes[_EnIf] & " " & result[1] & " Then"
      
   ElseIf Text.AreEquals(command, OrgTokes[_EnElseIf], False) Then
      result = BuildExpressionText(2)
      If ConvertToEnSahla Then
         Return DestTokes[_EnElseIf] & " " & result[1]
      EndIf
      Return DestTokes[_EnElseIf] & " " & result[1] & " Then"
      
   ElseIf Text.AreEquals(command, OrgTokes[_EnElse], False) Then
      Return DestTokes[_EnElse]
      
   ElseIf Text.AreEquals(command, OrgTokes[_EnEndIf], False) Then
      Return DestTokes[_EnEndIf]
      
   ElseIf Text.AreEquals(command, OrgTokes[_EnExitLoop], False) Then
      If ConvertToEnSahla Then
         Return DestTokes[_EnExitLoop]
      EndIf
      Return "ExitLoop"
      
   ElseIf Text.AreEquals(command, OrgTokes[_EnSound], False) Then
      nextCommand = Tokens[2][3]
      If Text.AreEquals(nextCommand, OrgTokes[_EnBeep], False) Then
         If ConvertToEnSahla Then
            Return DestTokes[_EnSound] & " " & DestTokes[_EnBeep]
         EndIf
         Return "Sound.PlayBeep()"
      ElseIf Text.AreEquals(nextCommand, OrgTokes[_EnBell], False) Then
         If ConvertToEnSahla Then
            Return DestTokes[_EnSound] & " " & DestTokes[_EnBell]
         EndIf
         Return "Sound.PlayBellRing()"
      ElseIf Text.AreEquals(nextCommand, OrgTokes[_EnDing], False) Then
         If ConvertToEnSahla Then
            Return DestTokes[_EnSound] & " " & DestTokes[_EnDing]
         EndIf
         Return "Sound.PlayDing()"
      ElseIf Text.AreEquals(nextCommand, OrgTokes[_EnClick], False) Then
         If ConvertToEnSahla Then
            Return DestTokes[_EnSound] & " " & DestTokes[_EnClick]
         EndIf
         Return "Sound.PlayClick()"
      ElseIf Text.AreEquals(nextCommand, OrgTokes[_EnChime], False) Then
         If ConvertToEnSahla Then
            Return DestTokes[_EnSound] & " " & DestTokes[_EnChime]
         EndIf
         Return "Sound.PlayChime()"
      Else
         result = BuildExpressionText(2)
         If ConvertToEnSahla Then
            Return DestTokes[_EnSound] & " " & result[1]
         EndIf
         Return "Sound.Play(" & result[1] & ")"
      EndIf
      
   ElseIf tokensCount >= 3 And Text.AreEquals(Tokens[2][3], "=", True) Then ' varName
      result = BuildExpressionText(3)
      Vars[command] = ConvertVarName(command)
      Return Vars[command] & " = " & result[1]
      
   Else
      Return Statements[LineIndex]
   EndIf
EndFunction


Function ConvertForLoopHeader()
   tokensCount = Tokens.Count
   varName = Tokens[2][3]
   Vars[varName] = ConvertVarName(varName)
   result = BuildExpressionText(4)
   startValue = result[1]
   nextPos = result[2]
   nextToken = Tokens[nextPos][3]
   result = BuildExpressionText(nextPos + 1)
   endValue = result[1]
   nextPos = result[2]
   stepIsMissing = True
   
   If nextPos <= tokensCount Then
      nextToken = Tokens[nextPos][3]
      If Text.AreEquals(nextToken, OrgTokes[_EnStep], False) Then
         result = BuildExpressionText(nextPos + 1)
         stepValue = result[1]
         stepIsMissing = False
      EndIf
   EndIf
   
   forHeader = DestTokes[_EnFor] & " " & Vars[varName] & " = " & startValue & " " & DestTokes[_EnTo1] & " " & endValue
   If stepIsMissing Then
      Return forHeader
   Else
      Return forHeader & " " & DestTokes[_EnStep] & " " & stepValue
   EndIf
EndFunction


Function BuildExpressionText(start)
   result = ConvertExpression(start)
   nextPos = result[2]
   token = Tokens[nextPos][3]
   
   If Text.StartsWith(Text.Trim(token), OrgTokes[_EnCommmentSymbol]) Then
      i = Text.IndexOf(token, OrgTokes[_EnCommmentSymbol], 1, False)
      token[i] = DestTokes[_EnCommmentSymbol]
      Return {result[1] & token, nextPos + 1}
   Else
      Return result
   EndIf
EndFunction

Function ConvertExpression(pos)
   Return ConvertOr(pos)
EndFunction

Function ConvertOr(pos)
   arr = ConvertAnd(pos)
   result = arr[1]
   pos = arr[2]
   tokensCount = Tokens.Count
   
   While pos <= tokensCount And Text.AreEquals(Tokens[pos][3], OrgTokes[_EnOr], False)
      pos = pos + 1
      arr2 = ConvertAnd(pos)
      result = " " & result & " " & DestTokes[_EnOr] & " " & arr2[1]
      pos = arr2[2]
   Wend
   Return {result, pos}
EndFunction

Function ConvertAnd(pos)
   arr = ConvertComparison(pos)
   result = arr[1]
   pos = arr[2]
   tokensCount = Tokens.Count
   
   While pos <= tokensCount And Text.AreEquals(Tokens[pos][3], OrgTokes[_EnAnd], False)
      pos = pos + 1
      arr2 = ConvertComparison(pos)
      result = " " & result & " " & DestTokes[_EnAnd] & " " & arr2[1]
      pos = arr2[2]
   Wend
   Return {result, pos}
EndFunction

Function ConvertComparison(pos)
   arr = ConvertAddExpr(pos)
   result = arr[1]
   pos = arr[2]
   
   If pos <= Tokens.Count Then
      op = Tokens[pos][3]
      If pos <> "" And (Text.AreEquals(op, "<", True)
            Or Text.AreEquals(op, ">", True)
            Or Text.AreEquals(op, "=", True)) Then
         nextOp = Tokens[pos + 1][3]
         
         If Text.AreEquals(nextOp, "=", True)
               Or Text.AreEquals(nextOp, ">", True) Then
            pos = pos + 2
         Else
            pos = pos + 1
         EndIf
         
         arr2 = ConvertAddExpr(pos)
         right = arr2[1]
         pos = arr2[2]
         
         If op = "<" Then
            If Text.AreEquals(nextOp, "=", True) Then
               result = " " & result & " <= " & right
            ElseIf Text.AreEquals(nextOp, ">", True) Then
               result = " " & result & " <> " & right
            Else
               result = " " & result & " < " & right
            EndIf
            
         ElseIf op = ">" Then
            If nextOp = "=" Then
               result = " " & result & " >= " & right
            Else
               result = " " & result & " > " & right
            EndIf
         Else
            result = " " & result & " = " & right
         EndIf
      EndIf
   EndIf
   Return {result, pos}
EndFunction

Function ConvertAddExpr(pos)
   arr = ConvertTerm(pos)
   leftValue = arr[1]
   pos = arr[2]
   op = Tokens[pos][3]
   tokensCount = Tokens.Count
   
   While pos <= tokensCount And (
         Text.AreEquals(op, "+", True)
         Or Text.AreEquals(op, "-", True))
      pos = pos + 1
      arr2 = ConvertTerm(pos)
      rightValue = arr2[1]
      
      If op = "+" Then
         leftValue = " " & leftValue & " + " & rightValue
      Else
         leftValue = " " & leftValue & " - " & rightValue
      EndIf
      
      pos = arr2[2]
      op = Tokens[pos][3]
   Wend
   Return {leftValue, pos}
EndFunction

Function ConvertPower(pos)
   arr = ConvertFactor(pos)
   leftValue = arr[1]
   pos = arr[2]
   op = Text.Trim(Tokens[pos][3])
   tokensCount = Tokens.Count
   
   If op[1] = _CommentSymbol Then
      Return {leftValue, pos}
   EndIf
   
   While pos <= tokensCount And Text.AreEquals(op, "^", True)
      pos = pos + 1
      arr2 = ConvertFactor(pos)
      rightValue = arr2[1]
      If ConvertToEnSahla Then
         leftValue = " " & leftValue & " ^ " & rightValue
      Else
         leftValue = "Math.Power(" & leftValue & ", " & rightValue & ")"
      EndIf
      
      pos = arr2[2]
      op = Tokens[pos][3]
   Wend
   
   Return {leftValue, pos}
EndFunction

Function ConvertTerm(pos)
   arr = ConvertPower(pos)
   leftValue = arr[1]
   pos = arr[2]
   op = Text.Trim(Tokens[pos][3])
   tokensCount = Tokens.Count
   
   While pos <= tokensCount And ( _
         Text.AreEquals(op, "*", True)
         Or Text.AreEquals(op, "×", True)
         Or Text.AreEquals(op, "/", True)
         Or Text.AreEquals(op, OrgTokes[_EnIntegralDivision], True)
         Or Text.AreEquals(op, "%", True)
         Or Text.AreEquals(op, "^", True))
      pos = pos + 1
      arr2 = ConvertPower(pos)
      rightValue = arr2[1]
      
      If op = "*" Or op = "×" Then
         leftValue = " " & leftValue & " * " & rightValue
      ElseIf op = "/" Then
         leftValue = " " & leftValue & " / " & rightValue
      ElseIf op = OrgTokes[_EnIntegralDivision] Then
         If ConvertToEnSahla Then
            leftValue = " " & leftValue & " " & DestTokes[_EnIntegralDivision] & " " & rightValue
         Else
            leftValue = "Math.Truncate(" & leftValue & " / " & rightValue & ")"
         EndIf
      ElseIf ConvertToEnSahla Then
         leftValue = " " & leftValue & " % " & rightValue
      Else
         leftValue = " " & leftValue & " Mod " & rightValue
      EndIf
      
      pos = arr2[2]
      op = Tokens[pos][3]
   Wend
   
   Return {leftValue, pos}
EndFunction

Function ConvertFactor(pos)
   token = Text.Trim(Tokens[pos][3])
   tokensCount = Tokens.Count
   
   If Text.AreEquals(token, OrgTokes[_EnTrue], False) Then
      Return {DestTokes[_EnTrue], pos + 1}
      
   ElseIf Text.AreEquals(token, OrgTokes[_EnFalse], False) Then
      Return {DestTokes[_EnFalse], pos + 1}
      
   ElseIf Text.AreEquals(token, "(", True) Then
      wordID = pos
      pos = pos + 1
      arr = ConvertExpression(pos)
      result = "(" & arr[1] & ")"
      pos = arr[2]
      If pos <= tokensCount And Text.AreEquals(Tokens[pos][3], ")", True) Then
         pos = pos + 1
      EndIf
      Return {result, pos}
      
   ElseIf Text.AreEquals(token, OrgTokes[_EnRandom], False) Then
      If ConvertToEnSahla Then
         Return {DestTokes[_EnRandom], pos + 1}
      EndIf
      Return {"Math.GetRandomNumber(100)", pos + 1}
      
   ElseIf Text.AreEquals(token, OrgTokes[_EnRead], False) Then
      pos = pos + 1
      If pos <= tokensCount Then
         nextToken = Tokens[pos][3]
         If Text.AreEquals(nextToken, OrgTokes[_EnText1], False)
               Or Text.AreEquals(nextToken, OrgTokes[_EnText2], False) Then
            If ConvertToEnSahla Then
               Return {DestTokes[_EnRead] & " " & DestTokes[_EnText1], pos + 1}
            EndIf
            Return {"TextWindow.Read()", pos + 1}
            
         ElseIf Text.AreEquals(nextToken, OrgTokes[_EnNumber1], False)
               Or Text.AreEquals(nextToken, OrgTokes[_EnNumber2], False) Then
            If ConvertToEnSahla Then
               Return {DestTokes[_EnRead] & " " & DestTokes[_EnNumber1], pos + 1}
            EndIf
            Return {"TextWindow.ReadNumber()", pos + 1}
         EndIf
      EndIf
      Return {0, pos}
      
   ElseIf Text.IsNumeric(token) Or (Text.StartsWith(token, """") And Text.EndsWith(token, """")) Then
      Return {token, pos + 1}
      
   ElseIf Vars[token] <> "" Then
      Return {Vars[token], pos + 1}
   EndIf
   
   Return {token, pos + 1}
EndFunction

Function ConvertVarName(varName)
   toNative = LettersMap["a"] <> ""
   If toNative Then
      varName = varName.Replace("asion", "ajn")
      varName = varName.Replace("esion", "ejn")
      varName = varName.Replace("ision", "ijn")
      varName = varName.Replace("osion", "ojn")
      varName = varName.Replace("usion", "ujn")
      varName = varName.Replace("rsion", "rjn")
      varName = varName.Replace("ssion", "shn")
      varName = varName.Replace("sion", "shn")
      varName = varName.Replace("stion", "stshn")
      varName = varName.Replace("tion", "shn")
   EndIf
   
   newName = ""
   prevC = ""
   len = Text.GetLength(varName)
   
   For i = 1 To len
      c = varName[i]
      If toNative Then
         If i = 1 Then
            If c = "a" Then
               newName = newName + "أ"
               ContinueLoop
               
            ElseIf c = "o" Then
               nextC = varName[i + 1]
               If nextC = "u" Then
                  newName = newName + "آو"
               ElseIf nextC = "w" Then
                  newName = newName + "أو"
               Else
                  newName = newName + "أ"
               EndIf
               ContinueLoop
               
            ElseIf c = "e" Then
               If nextC = "a" Or nextC = "e" Or nextC = "i" Then
                  newName = newName + "إي"
               ElseIf nextC = "y" Then
                  newName = newName + "آي"
               Else
                  newName = newName + "إ"
               EndIf
               ContinueLoop
               
            ElseIf c = "i" Then
               newName = newName + "إ"
               ContinueLoop
            ElseIf c = "u" Then
               newName = newName + "يو"
               ContinueLoop
            EndIf
            
         ElseIf i = len And c = "e" Then
            ExitLoop
         ElseIf newName.EndsWith("_") = False And c <> Text.ToLower(c) Then
            newName = newName + "_"
         EndIf
      EndIf
      
      c2 = Text.GetSubText(varName, i, 2)
      outChar = LettersMap[c2]
      
      If i = len Or outChar = "" Then
         If prevC <> c Then
            If c.ToLower() = "x" And (i = 1 Or newName.EndsWith("_")) Then
               newName = newName + "إكس"
            Else
               outChar = LettersMap[c]
               If outChar = "" Then
                  newName = newName + c
               Else
                  newName = newName + outChar
               EndIf
            EndIf
            prevC = c
         EndIf
      Else
         newName = newName + outChar
         i = i + 1
         prevC = ""
      EndIf
   Next
   Return newName
EndFunction
